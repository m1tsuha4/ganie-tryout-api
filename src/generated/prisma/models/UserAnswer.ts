/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `UserAnswer` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model UserAnswer
 *
 */
export type UserAnswerModel =
  runtime.Types.Result.DefaultSelection<Prisma.$UserAnswerPayload>;

export type AggregateUserAnswer = {
  _count: UserAnswerCountAggregateOutputType | null;
  _avg: UserAnswerAvgAggregateOutputType | null;
  _sum: UserAnswerSumAggregateOutputType | null;
  _min: UserAnswerMinAggregateOutputType | null;
  _max: UserAnswerMaxAggregateOutputType | null;
};

export type UserAnswerAvgAggregateOutputType = {
  id: number | null;
  session_id: number | null;
  question_id: number | null;
  choice_id: number | null;
};

export type UserAnswerSumAggregateOutputType = {
  id: number | null;
  session_id: number | null;
  question_id: number | null;
  choice_id: number | null;
};

export type UserAnswerMinAggregateOutputType = {
  id: number | null;
  session_id: number | null;
  question_id: number | null;
  choice_id: number | null;
  created_at: Date | null;
  updated_at: Date | null;
};

export type UserAnswerMaxAggregateOutputType = {
  id: number | null;
  session_id: number | null;
  question_id: number | null;
  choice_id: number | null;
  created_at: Date | null;
  updated_at: Date | null;
};

export type UserAnswerCountAggregateOutputType = {
  id: number;
  session_id: number;
  question_id: number;
  choice_id: number;
  created_at: number;
  updated_at: number;
  _all: number;
};

export type UserAnswerAvgAggregateInputType = {
  id?: true;
  session_id?: true;
  question_id?: true;
  choice_id?: true;
};

export type UserAnswerSumAggregateInputType = {
  id?: true;
  session_id?: true;
  question_id?: true;
  choice_id?: true;
};

export type UserAnswerMinAggregateInputType = {
  id?: true;
  session_id?: true;
  question_id?: true;
  choice_id?: true;
  created_at?: true;
  updated_at?: true;
};

export type UserAnswerMaxAggregateInputType = {
  id?: true;
  session_id?: true;
  question_id?: true;
  choice_id?: true;
  created_at?: true;
  updated_at?: true;
};

export type UserAnswerCountAggregateInputType = {
  id?: true;
  session_id?: true;
  question_id?: true;
  choice_id?: true;
  created_at?: true;
  updated_at?: true;
  _all?: true;
};

export type UserAnswerAggregateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which UserAnswer to aggregate.
   */
  where?: Prisma.UserAnswerWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of UserAnswers to fetch.
   */
  orderBy?:
    | Prisma.UserAnswerOrderByWithRelationInput
    | Prisma.UserAnswerOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.UserAnswerWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` UserAnswers from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` UserAnswers.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned UserAnswers
   **/
  _count?: true | UserAnswerCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to average
   **/
  _avg?: UserAnswerAvgAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to sum
   **/
  _sum?: UserAnswerSumAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: UserAnswerMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: UserAnswerMaxAggregateInputType;
};

export type GetUserAnswerAggregateType<T extends UserAnswerAggregateArgs> = {
  [P in keyof T & keyof AggregateUserAnswer]: P extends "_count" | "count"
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateUserAnswer[P]>
    : Prisma.GetScalarType<T[P], AggregateUserAnswer[P]>;
};

export type UserAnswerGroupByArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.UserAnswerWhereInput;
  orderBy?:
    | Prisma.UserAnswerOrderByWithAggregationInput
    | Prisma.UserAnswerOrderByWithAggregationInput[];
  by: Prisma.UserAnswerScalarFieldEnum[] | Prisma.UserAnswerScalarFieldEnum;
  having?: Prisma.UserAnswerScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: UserAnswerCountAggregateInputType | true;
  _avg?: UserAnswerAvgAggregateInputType;
  _sum?: UserAnswerSumAggregateInputType;
  _min?: UserAnswerMinAggregateInputType;
  _max?: UserAnswerMaxAggregateInputType;
};

export type UserAnswerGroupByOutputType = {
  id: number;
  session_id: number;
  question_id: number;
  choice_id: number;
  created_at: Date;
  updated_at: Date;
  _count: UserAnswerCountAggregateOutputType | null;
  _avg: UserAnswerAvgAggregateOutputType | null;
  _sum: UserAnswerSumAggregateOutputType | null;
  _min: UserAnswerMinAggregateOutputType | null;
  _max: UserAnswerMaxAggregateOutputType | null;
};

type GetUserAnswerGroupByPayload<T extends UserAnswerGroupByArgs> =
  Prisma.PrismaPromise<
    Array<
      Prisma.PickEnumerable<UserAnswerGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserAnswerGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], UserAnswerGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], UserAnswerGroupByOutputType[P]>;
      }
    >
  >;

export type UserAnswerWhereInput = {
  AND?: Prisma.UserAnswerWhereInput | Prisma.UserAnswerWhereInput[];
  OR?: Prisma.UserAnswerWhereInput[];
  NOT?: Prisma.UserAnswerWhereInput | Prisma.UserAnswerWhereInput[];
  id?: Prisma.IntFilter<"UserAnswer"> | number;
  session_id?: Prisma.IntFilter<"UserAnswer"> | number;
  question_id?: Prisma.IntFilter<"UserAnswer"> | number;
  choice_id?: Prisma.IntFilter<"UserAnswer"> | number;
  created_at?: Prisma.DateTimeFilter<"UserAnswer"> | Date | string;
  updated_at?: Prisma.DateTimeFilter<"UserAnswer"> | Date | string;
  session?: Prisma.XOR<
    Prisma.UserExamSessionScalarRelationFilter,
    Prisma.UserExamSessionWhereInput
  >;
  question?: Prisma.XOR<
    Prisma.QuestionScalarRelationFilter,
    Prisma.QuestionWhereInput
  >;
  choice?: Prisma.XOR<
    Prisma.QuestionChoiceScalarRelationFilter,
    Prisma.QuestionChoiceWhereInput
  >;
};

export type UserAnswerOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  session_id?: Prisma.SortOrder;
  question_id?: Prisma.SortOrder;
  choice_id?: Prisma.SortOrder;
  created_at?: Prisma.SortOrder;
  updated_at?: Prisma.SortOrder;
  session?: Prisma.UserExamSessionOrderByWithRelationInput;
  question?: Prisma.QuestionOrderByWithRelationInput;
  choice?: Prisma.QuestionChoiceOrderByWithRelationInput;
};

export type UserAnswerWhereUniqueInput = Prisma.AtLeast<
  {
    id?: number;
    AND?: Prisma.UserAnswerWhereInput | Prisma.UserAnswerWhereInput[];
    OR?: Prisma.UserAnswerWhereInput[];
    NOT?: Prisma.UserAnswerWhereInput | Prisma.UserAnswerWhereInput[];
    session_id?: Prisma.IntFilter<"UserAnswer"> | number;
    question_id?: Prisma.IntFilter<"UserAnswer"> | number;
    choice_id?: Prisma.IntFilter<"UserAnswer"> | number;
    created_at?: Prisma.DateTimeFilter<"UserAnswer"> | Date | string;
    updated_at?: Prisma.DateTimeFilter<"UserAnswer"> | Date | string;
    session?: Prisma.XOR<
      Prisma.UserExamSessionScalarRelationFilter,
      Prisma.UserExamSessionWhereInput
    >;
    question?: Prisma.XOR<
      Prisma.QuestionScalarRelationFilter,
      Prisma.QuestionWhereInput
    >;
    choice?: Prisma.XOR<
      Prisma.QuestionChoiceScalarRelationFilter,
      Prisma.QuestionChoiceWhereInput
    >;
  },
  "id"
>;

export type UserAnswerOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  session_id?: Prisma.SortOrder;
  question_id?: Prisma.SortOrder;
  choice_id?: Prisma.SortOrder;
  created_at?: Prisma.SortOrder;
  updated_at?: Prisma.SortOrder;
  _count?: Prisma.UserAnswerCountOrderByAggregateInput;
  _avg?: Prisma.UserAnswerAvgOrderByAggregateInput;
  _max?: Prisma.UserAnswerMaxOrderByAggregateInput;
  _min?: Prisma.UserAnswerMinOrderByAggregateInput;
  _sum?: Prisma.UserAnswerSumOrderByAggregateInput;
};

export type UserAnswerScalarWhereWithAggregatesInput = {
  AND?:
    | Prisma.UserAnswerScalarWhereWithAggregatesInput
    | Prisma.UserAnswerScalarWhereWithAggregatesInput[];
  OR?: Prisma.UserAnswerScalarWhereWithAggregatesInput[];
  NOT?:
    | Prisma.UserAnswerScalarWhereWithAggregatesInput
    | Prisma.UserAnswerScalarWhereWithAggregatesInput[];
  id?: Prisma.IntWithAggregatesFilter<"UserAnswer"> | number;
  session_id?: Prisma.IntWithAggregatesFilter<"UserAnswer"> | number;
  question_id?: Prisma.IntWithAggregatesFilter<"UserAnswer"> | number;
  choice_id?: Prisma.IntWithAggregatesFilter<"UserAnswer"> | number;
  created_at?:
    | Prisma.DateTimeWithAggregatesFilter<"UserAnswer">
    | Date
    | string;
  updated_at?:
    | Prisma.DateTimeWithAggregatesFilter<"UserAnswer">
    | Date
    | string;
};

export type UserAnswerCreateInput = {
  created_at?: Date | string;
  updated_at?: Date | string;
  session: Prisma.UserExamSessionCreateNestedOneWithoutUser_answersInput;
  question: Prisma.QuestionCreateNestedOneWithoutUser_answersInput;
  choice: Prisma.QuestionChoiceCreateNestedOneWithoutUser_answersInput;
};

export type UserAnswerUncheckedCreateInput = {
  id?: number;
  session_id: number;
  question_id: number;
  choice_id: number;
  created_at?: Date | string;
  updated_at?: Date | string;
};

export type UserAnswerUpdateInput = {
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  session?: Prisma.UserExamSessionUpdateOneRequiredWithoutUser_answersNestedInput;
  question?: Prisma.QuestionUpdateOneRequiredWithoutUser_answersNestedInput;
  choice?: Prisma.QuestionChoiceUpdateOneRequiredWithoutUser_answersNestedInput;
};

export type UserAnswerUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  session_id?: Prisma.IntFieldUpdateOperationsInput | number;
  question_id?: Prisma.IntFieldUpdateOperationsInput | number;
  choice_id?: Prisma.IntFieldUpdateOperationsInput | number;
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserAnswerCreateManyInput = {
  id?: number;
  session_id: number;
  question_id: number;
  choice_id: number;
  created_at?: Date | string;
  updated_at?: Date | string;
};

export type UserAnswerUpdateManyMutationInput = {
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserAnswerUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  session_id?: Prisma.IntFieldUpdateOperationsInput | number;
  question_id?: Prisma.IntFieldUpdateOperationsInput | number;
  choice_id?: Prisma.IntFieldUpdateOperationsInput | number;
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserAnswerListRelationFilter = {
  every?: Prisma.UserAnswerWhereInput;
  some?: Prisma.UserAnswerWhereInput;
  none?: Prisma.UserAnswerWhereInput;
};

export type UserAnswerOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder;
};

export type UserAnswerCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  session_id?: Prisma.SortOrder;
  question_id?: Prisma.SortOrder;
  choice_id?: Prisma.SortOrder;
  created_at?: Prisma.SortOrder;
  updated_at?: Prisma.SortOrder;
};

export type UserAnswerAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  session_id?: Prisma.SortOrder;
  question_id?: Prisma.SortOrder;
  choice_id?: Prisma.SortOrder;
};

export type UserAnswerMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  session_id?: Prisma.SortOrder;
  question_id?: Prisma.SortOrder;
  choice_id?: Prisma.SortOrder;
  created_at?: Prisma.SortOrder;
  updated_at?: Prisma.SortOrder;
};

export type UserAnswerMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  session_id?: Prisma.SortOrder;
  question_id?: Prisma.SortOrder;
  choice_id?: Prisma.SortOrder;
  created_at?: Prisma.SortOrder;
  updated_at?: Prisma.SortOrder;
};

export type UserAnswerSumOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  session_id?: Prisma.SortOrder;
  question_id?: Prisma.SortOrder;
  choice_id?: Prisma.SortOrder;
};

export type UserAnswerCreateNestedManyWithoutQuestionInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutQuestionInput,
        Prisma.UserAnswerUncheckedCreateWithoutQuestionInput
      >
    | Prisma.UserAnswerCreateWithoutQuestionInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutQuestionInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutQuestionInput
    | Prisma.UserAnswerCreateOrConnectWithoutQuestionInput[];
  createMany?: Prisma.UserAnswerCreateManyQuestionInputEnvelope;
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
};

export type UserAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutQuestionInput,
        Prisma.UserAnswerUncheckedCreateWithoutQuestionInput
      >
    | Prisma.UserAnswerCreateWithoutQuestionInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutQuestionInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutQuestionInput
    | Prisma.UserAnswerCreateOrConnectWithoutQuestionInput[];
  createMany?: Prisma.UserAnswerCreateManyQuestionInputEnvelope;
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
};

export type UserAnswerUpdateManyWithoutQuestionNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutQuestionInput,
        Prisma.UserAnswerUncheckedCreateWithoutQuestionInput
      >
    | Prisma.UserAnswerCreateWithoutQuestionInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutQuestionInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutQuestionInput
    | Prisma.UserAnswerCreateOrConnectWithoutQuestionInput[];
  upsert?:
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutQuestionInput
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutQuestionInput[];
  createMany?: Prisma.UserAnswerCreateManyQuestionInputEnvelope;
  set?: Prisma.UserAnswerWhereUniqueInput | Prisma.UserAnswerWhereUniqueInput[];
  disconnect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  delete?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  update?:
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutQuestionInput
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutQuestionInput[];
  updateMany?:
    | Prisma.UserAnswerUpdateManyWithWhereWithoutQuestionInput
    | Prisma.UserAnswerUpdateManyWithWhereWithoutQuestionInput[];
  deleteMany?:
    | Prisma.UserAnswerScalarWhereInput
    | Prisma.UserAnswerScalarWhereInput[];
};

export type UserAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutQuestionInput,
        Prisma.UserAnswerUncheckedCreateWithoutQuestionInput
      >
    | Prisma.UserAnswerCreateWithoutQuestionInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutQuestionInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutQuestionInput
    | Prisma.UserAnswerCreateOrConnectWithoutQuestionInput[];
  upsert?:
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutQuestionInput
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutQuestionInput[];
  createMany?: Prisma.UserAnswerCreateManyQuestionInputEnvelope;
  set?: Prisma.UserAnswerWhereUniqueInput | Prisma.UserAnswerWhereUniqueInput[];
  disconnect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  delete?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  update?:
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutQuestionInput
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutQuestionInput[];
  updateMany?:
    | Prisma.UserAnswerUpdateManyWithWhereWithoutQuestionInput
    | Prisma.UserAnswerUpdateManyWithWhereWithoutQuestionInput[];
  deleteMany?:
    | Prisma.UserAnswerScalarWhereInput
    | Prisma.UserAnswerScalarWhereInput[];
};

export type UserAnswerCreateNestedManyWithoutChoiceInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutChoiceInput,
        Prisma.UserAnswerUncheckedCreateWithoutChoiceInput
      >
    | Prisma.UserAnswerCreateWithoutChoiceInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutChoiceInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutChoiceInput
    | Prisma.UserAnswerCreateOrConnectWithoutChoiceInput[];
  createMany?: Prisma.UserAnswerCreateManyChoiceInputEnvelope;
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
};

export type UserAnswerUncheckedCreateNestedManyWithoutChoiceInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutChoiceInput,
        Prisma.UserAnswerUncheckedCreateWithoutChoiceInput
      >
    | Prisma.UserAnswerCreateWithoutChoiceInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutChoiceInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutChoiceInput
    | Prisma.UserAnswerCreateOrConnectWithoutChoiceInput[];
  createMany?: Prisma.UserAnswerCreateManyChoiceInputEnvelope;
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
};

export type UserAnswerUpdateManyWithoutChoiceNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutChoiceInput,
        Prisma.UserAnswerUncheckedCreateWithoutChoiceInput
      >
    | Prisma.UserAnswerCreateWithoutChoiceInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutChoiceInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutChoiceInput
    | Prisma.UserAnswerCreateOrConnectWithoutChoiceInput[];
  upsert?:
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutChoiceInput
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutChoiceInput[];
  createMany?: Prisma.UserAnswerCreateManyChoiceInputEnvelope;
  set?: Prisma.UserAnswerWhereUniqueInput | Prisma.UserAnswerWhereUniqueInput[];
  disconnect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  delete?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  update?:
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutChoiceInput
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutChoiceInput[];
  updateMany?:
    | Prisma.UserAnswerUpdateManyWithWhereWithoutChoiceInput
    | Prisma.UserAnswerUpdateManyWithWhereWithoutChoiceInput[];
  deleteMany?:
    | Prisma.UserAnswerScalarWhereInput
    | Prisma.UserAnswerScalarWhereInput[];
};

export type UserAnswerUncheckedUpdateManyWithoutChoiceNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutChoiceInput,
        Prisma.UserAnswerUncheckedCreateWithoutChoiceInput
      >
    | Prisma.UserAnswerCreateWithoutChoiceInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutChoiceInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutChoiceInput
    | Prisma.UserAnswerCreateOrConnectWithoutChoiceInput[];
  upsert?:
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutChoiceInput
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutChoiceInput[];
  createMany?: Prisma.UserAnswerCreateManyChoiceInputEnvelope;
  set?: Prisma.UserAnswerWhereUniqueInput | Prisma.UserAnswerWhereUniqueInput[];
  disconnect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  delete?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  update?:
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutChoiceInput
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutChoiceInput[];
  updateMany?:
    | Prisma.UserAnswerUpdateManyWithWhereWithoutChoiceInput
    | Prisma.UserAnswerUpdateManyWithWhereWithoutChoiceInput[];
  deleteMany?:
    | Prisma.UserAnswerScalarWhereInput
    | Prisma.UserAnswerScalarWhereInput[];
};

export type UserAnswerCreateNestedManyWithoutSessionInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutSessionInput,
        Prisma.UserAnswerUncheckedCreateWithoutSessionInput
      >
    | Prisma.UserAnswerCreateWithoutSessionInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutSessionInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutSessionInput
    | Prisma.UserAnswerCreateOrConnectWithoutSessionInput[];
  createMany?: Prisma.UserAnswerCreateManySessionInputEnvelope;
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
};

export type UserAnswerUncheckedCreateNestedManyWithoutSessionInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutSessionInput,
        Prisma.UserAnswerUncheckedCreateWithoutSessionInput
      >
    | Prisma.UserAnswerCreateWithoutSessionInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutSessionInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutSessionInput
    | Prisma.UserAnswerCreateOrConnectWithoutSessionInput[];
  createMany?: Prisma.UserAnswerCreateManySessionInputEnvelope;
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
};

export type UserAnswerUpdateManyWithoutSessionNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutSessionInput,
        Prisma.UserAnswerUncheckedCreateWithoutSessionInput
      >
    | Prisma.UserAnswerCreateWithoutSessionInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutSessionInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutSessionInput
    | Prisma.UserAnswerCreateOrConnectWithoutSessionInput[];
  upsert?:
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutSessionInput
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutSessionInput[];
  createMany?: Prisma.UserAnswerCreateManySessionInputEnvelope;
  set?: Prisma.UserAnswerWhereUniqueInput | Prisma.UserAnswerWhereUniqueInput[];
  disconnect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  delete?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  update?:
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutSessionInput
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutSessionInput[];
  updateMany?:
    | Prisma.UserAnswerUpdateManyWithWhereWithoutSessionInput
    | Prisma.UserAnswerUpdateManyWithWhereWithoutSessionInput[];
  deleteMany?:
    | Prisma.UserAnswerScalarWhereInput
    | Prisma.UserAnswerScalarWhereInput[];
};

export type UserAnswerUncheckedUpdateManyWithoutSessionNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.UserAnswerCreateWithoutSessionInput,
        Prisma.UserAnswerUncheckedCreateWithoutSessionInput
      >
    | Prisma.UserAnswerCreateWithoutSessionInput[]
    | Prisma.UserAnswerUncheckedCreateWithoutSessionInput[];
  connectOrCreate?:
    | Prisma.UserAnswerCreateOrConnectWithoutSessionInput
    | Prisma.UserAnswerCreateOrConnectWithoutSessionInput[];
  upsert?:
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutSessionInput
    | Prisma.UserAnswerUpsertWithWhereUniqueWithoutSessionInput[];
  createMany?: Prisma.UserAnswerCreateManySessionInputEnvelope;
  set?: Prisma.UserAnswerWhereUniqueInput | Prisma.UserAnswerWhereUniqueInput[];
  disconnect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  delete?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  connect?:
    | Prisma.UserAnswerWhereUniqueInput
    | Prisma.UserAnswerWhereUniqueInput[];
  update?:
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutSessionInput
    | Prisma.UserAnswerUpdateWithWhereUniqueWithoutSessionInput[];
  updateMany?:
    | Prisma.UserAnswerUpdateManyWithWhereWithoutSessionInput
    | Prisma.UserAnswerUpdateManyWithWhereWithoutSessionInput[];
  deleteMany?:
    | Prisma.UserAnswerScalarWhereInput
    | Prisma.UserAnswerScalarWhereInput[];
};

export type UserAnswerCreateWithoutQuestionInput = {
  created_at?: Date | string;
  updated_at?: Date | string;
  session: Prisma.UserExamSessionCreateNestedOneWithoutUser_answersInput;
  choice: Prisma.QuestionChoiceCreateNestedOneWithoutUser_answersInput;
};

export type UserAnswerUncheckedCreateWithoutQuestionInput = {
  id?: number;
  session_id: number;
  choice_id: number;
  created_at?: Date | string;
  updated_at?: Date | string;
};

export type UserAnswerCreateOrConnectWithoutQuestionInput = {
  where: Prisma.UserAnswerWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.UserAnswerCreateWithoutQuestionInput,
    Prisma.UserAnswerUncheckedCreateWithoutQuestionInput
  >;
};

export type UserAnswerCreateManyQuestionInputEnvelope = {
  data:
    | Prisma.UserAnswerCreateManyQuestionInput
    | Prisma.UserAnswerCreateManyQuestionInput[];
  skipDuplicates?: boolean;
};

export type UserAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
  where: Prisma.UserAnswerWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.UserAnswerUpdateWithoutQuestionInput,
    Prisma.UserAnswerUncheckedUpdateWithoutQuestionInput
  >;
  create: Prisma.XOR<
    Prisma.UserAnswerCreateWithoutQuestionInput,
    Prisma.UserAnswerUncheckedCreateWithoutQuestionInput
  >;
};

export type UserAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
  where: Prisma.UserAnswerWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.UserAnswerUpdateWithoutQuestionInput,
    Prisma.UserAnswerUncheckedUpdateWithoutQuestionInput
  >;
};

export type UserAnswerUpdateManyWithWhereWithoutQuestionInput = {
  where: Prisma.UserAnswerScalarWhereInput;
  data: Prisma.XOR<
    Prisma.UserAnswerUpdateManyMutationInput,
    Prisma.UserAnswerUncheckedUpdateManyWithoutQuestionInput
  >;
};

export type UserAnswerScalarWhereInput = {
  AND?: Prisma.UserAnswerScalarWhereInput | Prisma.UserAnswerScalarWhereInput[];
  OR?: Prisma.UserAnswerScalarWhereInput[];
  NOT?: Prisma.UserAnswerScalarWhereInput | Prisma.UserAnswerScalarWhereInput[];
  id?: Prisma.IntFilter<"UserAnswer"> | number;
  session_id?: Prisma.IntFilter<"UserAnswer"> | number;
  question_id?: Prisma.IntFilter<"UserAnswer"> | number;
  choice_id?: Prisma.IntFilter<"UserAnswer"> | number;
  created_at?: Prisma.DateTimeFilter<"UserAnswer"> | Date | string;
  updated_at?: Prisma.DateTimeFilter<"UserAnswer"> | Date | string;
};

export type UserAnswerCreateWithoutChoiceInput = {
  created_at?: Date | string;
  updated_at?: Date | string;
  session: Prisma.UserExamSessionCreateNestedOneWithoutUser_answersInput;
  question: Prisma.QuestionCreateNestedOneWithoutUser_answersInput;
};

export type UserAnswerUncheckedCreateWithoutChoiceInput = {
  id?: number;
  session_id: number;
  question_id: number;
  created_at?: Date | string;
  updated_at?: Date | string;
};

export type UserAnswerCreateOrConnectWithoutChoiceInput = {
  where: Prisma.UserAnswerWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.UserAnswerCreateWithoutChoiceInput,
    Prisma.UserAnswerUncheckedCreateWithoutChoiceInput
  >;
};

export type UserAnswerCreateManyChoiceInputEnvelope = {
  data:
    | Prisma.UserAnswerCreateManyChoiceInput
    | Prisma.UserAnswerCreateManyChoiceInput[];
  skipDuplicates?: boolean;
};

export type UserAnswerUpsertWithWhereUniqueWithoutChoiceInput = {
  where: Prisma.UserAnswerWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.UserAnswerUpdateWithoutChoiceInput,
    Prisma.UserAnswerUncheckedUpdateWithoutChoiceInput
  >;
  create: Prisma.XOR<
    Prisma.UserAnswerCreateWithoutChoiceInput,
    Prisma.UserAnswerUncheckedCreateWithoutChoiceInput
  >;
};

export type UserAnswerUpdateWithWhereUniqueWithoutChoiceInput = {
  where: Prisma.UserAnswerWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.UserAnswerUpdateWithoutChoiceInput,
    Prisma.UserAnswerUncheckedUpdateWithoutChoiceInput
  >;
};

export type UserAnswerUpdateManyWithWhereWithoutChoiceInput = {
  where: Prisma.UserAnswerScalarWhereInput;
  data: Prisma.XOR<
    Prisma.UserAnswerUpdateManyMutationInput,
    Prisma.UserAnswerUncheckedUpdateManyWithoutChoiceInput
  >;
};

export type UserAnswerCreateWithoutSessionInput = {
  created_at?: Date | string;
  updated_at?: Date | string;
  question: Prisma.QuestionCreateNestedOneWithoutUser_answersInput;
  choice: Prisma.QuestionChoiceCreateNestedOneWithoutUser_answersInput;
};

export type UserAnswerUncheckedCreateWithoutSessionInput = {
  id?: number;
  question_id: number;
  choice_id: number;
  created_at?: Date | string;
  updated_at?: Date | string;
};

export type UserAnswerCreateOrConnectWithoutSessionInput = {
  where: Prisma.UserAnswerWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.UserAnswerCreateWithoutSessionInput,
    Prisma.UserAnswerUncheckedCreateWithoutSessionInput
  >;
};

export type UserAnswerCreateManySessionInputEnvelope = {
  data:
    | Prisma.UserAnswerCreateManySessionInput
    | Prisma.UserAnswerCreateManySessionInput[];
  skipDuplicates?: boolean;
};

export type UserAnswerUpsertWithWhereUniqueWithoutSessionInput = {
  where: Prisma.UserAnswerWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.UserAnswerUpdateWithoutSessionInput,
    Prisma.UserAnswerUncheckedUpdateWithoutSessionInput
  >;
  create: Prisma.XOR<
    Prisma.UserAnswerCreateWithoutSessionInput,
    Prisma.UserAnswerUncheckedCreateWithoutSessionInput
  >;
};

export type UserAnswerUpdateWithWhereUniqueWithoutSessionInput = {
  where: Prisma.UserAnswerWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.UserAnswerUpdateWithoutSessionInput,
    Prisma.UserAnswerUncheckedUpdateWithoutSessionInput
  >;
};

export type UserAnswerUpdateManyWithWhereWithoutSessionInput = {
  where: Prisma.UserAnswerScalarWhereInput;
  data: Prisma.XOR<
    Prisma.UserAnswerUpdateManyMutationInput,
    Prisma.UserAnswerUncheckedUpdateManyWithoutSessionInput
  >;
};

export type UserAnswerCreateManyQuestionInput = {
  id?: number;
  session_id: number;
  choice_id: number;
  created_at?: Date | string;
  updated_at?: Date | string;
};

export type UserAnswerUpdateWithoutQuestionInput = {
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  session?: Prisma.UserExamSessionUpdateOneRequiredWithoutUser_answersNestedInput;
  choice?: Prisma.QuestionChoiceUpdateOneRequiredWithoutUser_answersNestedInput;
};

export type UserAnswerUncheckedUpdateWithoutQuestionInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  session_id?: Prisma.IntFieldUpdateOperationsInput | number;
  choice_id?: Prisma.IntFieldUpdateOperationsInput | number;
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserAnswerUncheckedUpdateManyWithoutQuestionInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  session_id?: Prisma.IntFieldUpdateOperationsInput | number;
  choice_id?: Prisma.IntFieldUpdateOperationsInput | number;
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserAnswerCreateManyChoiceInput = {
  id?: number;
  session_id: number;
  question_id: number;
  created_at?: Date | string;
  updated_at?: Date | string;
};

export type UserAnswerUpdateWithoutChoiceInput = {
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  session?: Prisma.UserExamSessionUpdateOneRequiredWithoutUser_answersNestedInput;
  question?: Prisma.QuestionUpdateOneRequiredWithoutUser_answersNestedInput;
};

export type UserAnswerUncheckedUpdateWithoutChoiceInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  session_id?: Prisma.IntFieldUpdateOperationsInput | number;
  question_id?: Prisma.IntFieldUpdateOperationsInput | number;
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserAnswerUncheckedUpdateManyWithoutChoiceInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  session_id?: Prisma.IntFieldUpdateOperationsInput | number;
  question_id?: Prisma.IntFieldUpdateOperationsInput | number;
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserAnswerCreateManySessionInput = {
  id?: number;
  question_id: number;
  choice_id: number;
  created_at?: Date | string;
  updated_at?: Date | string;
};

export type UserAnswerUpdateWithoutSessionInput = {
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  question?: Prisma.QuestionUpdateOneRequiredWithoutUser_answersNestedInput;
  choice?: Prisma.QuestionChoiceUpdateOneRequiredWithoutUser_answersNestedInput;
};

export type UserAnswerUncheckedUpdateWithoutSessionInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  question_id?: Prisma.IntFieldUpdateOperationsInput | number;
  choice_id?: Prisma.IntFieldUpdateOperationsInput | number;
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserAnswerUncheckedUpdateManyWithoutSessionInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  question_id?: Prisma.IntFieldUpdateOperationsInput | number;
  choice_id?: Prisma.IntFieldUpdateOperationsInput | number;
  created_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updated_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserAnswerSelect<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    session_id?: boolean;
    question_id?: boolean;
    choice_id?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    session?: boolean | Prisma.UserExamSessionDefaultArgs<ExtArgs>;
    question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
    choice?: boolean | Prisma.QuestionChoiceDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["userAnswer"]
>;

export type UserAnswerSelectCreateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    session_id?: boolean;
    question_id?: boolean;
    choice_id?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    session?: boolean | Prisma.UserExamSessionDefaultArgs<ExtArgs>;
    question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
    choice?: boolean | Prisma.QuestionChoiceDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["userAnswer"]
>;

export type UserAnswerSelectUpdateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    session_id?: boolean;
    question_id?: boolean;
    choice_id?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    session?: boolean | Prisma.UserExamSessionDefaultArgs<ExtArgs>;
    question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
    choice?: boolean | Prisma.QuestionChoiceDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["userAnswer"]
>;

export type UserAnswerSelectScalar = {
  id?: boolean;
  session_id?: boolean;
  question_id?: boolean;
  choice_id?: boolean;
  created_at?: boolean;
  updated_at?: boolean;
};

export type UserAnswerOmit<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  | "id"
  | "session_id"
  | "question_id"
  | "choice_id"
  | "created_at"
  | "updated_at",
  ExtArgs["result"]["userAnswer"]
>;
export type UserAnswerInclude<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  session?: boolean | Prisma.UserExamSessionDefaultArgs<ExtArgs>;
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
  choice?: boolean | Prisma.QuestionChoiceDefaultArgs<ExtArgs>;
};
export type UserAnswerIncludeCreateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  session?: boolean | Prisma.UserExamSessionDefaultArgs<ExtArgs>;
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
  choice?: boolean | Prisma.QuestionChoiceDefaultArgs<ExtArgs>;
};
export type UserAnswerIncludeUpdateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  session?: boolean | Prisma.UserExamSessionDefaultArgs<ExtArgs>;
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
  choice?: boolean | Prisma.QuestionChoiceDefaultArgs<ExtArgs>;
};

export type $UserAnswerPayload<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  name: "UserAnswer";
  objects: {
    session: Prisma.$UserExamSessionPayload<ExtArgs>;
    question: Prisma.$QuestionPayload<ExtArgs>;
    choice: Prisma.$QuestionChoicePayload<ExtArgs>;
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: number;
      session_id: number;
      question_id: number;
      choice_id: number;
      created_at: Date;
      updated_at: Date;
    },
    ExtArgs["result"]["userAnswer"]
  >;
  composites: {};
};

export type UserAnswerGetPayload<
  S extends boolean | null | undefined | UserAnswerDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$UserAnswerPayload, S>;

export type UserAnswerCountArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<UserAnswerFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
  select?: UserAnswerCountAggregateInputType | true;
};

export interface UserAnswerDelegate<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: {
    types: Prisma.TypeMap<ExtArgs>["model"]["UserAnswer"];
    meta: { name: "UserAnswer" };
  };
  /**
   * Find zero or one UserAnswer that matches the filter.
   * @param {UserAnswerFindUniqueArgs} args - Arguments to find a UserAnswer
   * @example
   * // Get one UserAnswer
   * const userAnswer = await prisma.userAnswer.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends UserAnswerFindUniqueArgs>(
    args: Prisma.SelectSubset<T, UserAnswerFindUniqueArgs<ExtArgs>>,
  ): Prisma.Prisma__UserAnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "findUnique",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one UserAnswer that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {UserAnswerFindUniqueOrThrowArgs} args - Arguments to find a UserAnswer
   * @example
   * // Get one UserAnswer
   * const userAnswer = await prisma.userAnswer.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends UserAnswerFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, UserAnswerFindUniqueOrThrowArgs<ExtArgs>>,
  ): Prisma.Prisma__UserAnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first UserAnswer that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserAnswerFindFirstArgs} args - Arguments to find a UserAnswer
   * @example
   * // Get one UserAnswer
   * const userAnswer = await prisma.userAnswer.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends UserAnswerFindFirstArgs>(
    args?: Prisma.SelectSubset<T, UserAnswerFindFirstArgs<ExtArgs>>,
  ): Prisma.Prisma__UserAnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "findFirst",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first UserAnswer that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserAnswerFindFirstOrThrowArgs} args - Arguments to find a UserAnswer
   * @example
   * // Get one UserAnswer
   * const userAnswer = await prisma.userAnswer.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends UserAnswerFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, UserAnswerFindFirstOrThrowArgs<ExtArgs>>,
  ): Prisma.Prisma__UserAnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "findFirstOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more UserAnswers that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all UserAnswers
   * const userAnswers = await prisma.userAnswer.findMany()
   *
   * // Get first 10 UserAnswers
   * const userAnswers = await prisma.userAnswer.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const userAnswerWithIdOnly = await prisma.userAnswer.findMany({ select: { id: true } })
   *
   */
  findMany<T extends UserAnswerFindManyArgs>(
    args?: Prisma.SelectSubset<T, UserAnswerFindManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "findMany",
      GlobalOmitOptions
    >
  >;

  /**
   * Create a UserAnswer.
   * @param {UserAnswerCreateArgs} args - Arguments to create a UserAnswer.
   * @example
   * // Create one UserAnswer
   * const UserAnswer = await prisma.userAnswer.create({
   *   data: {
   *     // ... data to create a UserAnswer
   *   }
   * })
   *
   */
  create<T extends UserAnswerCreateArgs>(
    args: Prisma.SelectSubset<T, UserAnswerCreateArgs<ExtArgs>>,
  ): Prisma.Prisma__UserAnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "create",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many UserAnswers.
   * @param {UserAnswerCreateManyArgs} args - Arguments to create many UserAnswers.
   * @example
   * // Create many UserAnswers
   * const userAnswer = await prisma.userAnswer.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends UserAnswerCreateManyArgs>(
    args?: Prisma.SelectSubset<T, UserAnswerCreateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many UserAnswers and returns the data saved in the database.
   * @param {UserAnswerCreateManyAndReturnArgs} args - Arguments to create many UserAnswers.
   * @example
   * // Create many UserAnswers
   * const userAnswer = await prisma.userAnswer.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many UserAnswers and only return the `id`
   * const userAnswerWithIdOnly = await prisma.userAnswer.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends UserAnswerCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, UserAnswerCreateManyAndReturnArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "createManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a UserAnswer.
   * @param {UserAnswerDeleteArgs} args - Arguments to delete one UserAnswer.
   * @example
   * // Delete one UserAnswer
   * const UserAnswer = await prisma.userAnswer.delete({
   *   where: {
   *     // ... filter to delete one UserAnswer
   *   }
   * })
   *
   */
  delete<T extends UserAnswerDeleteArgs>(
    args: Prisma.SelectSubset<T, UserAnswerDeleteArgs<ExtArgs>>,
  ): Prisma.Prisma__UserAnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "delete",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one UserAnswer.
   * @param {UserAnswerUpdateArgs} args - Arguments to update one UserAnswer.
   * @example
   * // Update one UserAnswer
   * const userAnswer = await prisma.userAnswer.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends UserAnswerUpdateArgs>(
    args: Prisma.SelectSubset<T, UserAnswerUpdateArgs<ExtArgs>>,
  ): Prisma.Prisma__UserAnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "update",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more UserAnswers.
   * @param {UserAnswerDeleteManyArgs} args - Arguments to filter UserAnswers to delete.
   * @example
   * // Delete a few UserAnswers
   * const { count } = await prisma.userAnswer.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends UserAnswerDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, UserAnswerDeleteManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more UserAnswers.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserAnswerUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many UserAnswers
   * const userAnswer = await prisma.userAnswer.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends UserAnswerUpdateManyArgs>(
    args: Prisma.SelectSubset<T, UserAnswerUpdateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more UserAnswers and returns the data updated in the database.
   * @param {UserAnswerUpdateManyAndReturnArgs} args - Arguments to update many UserAnswers.
   * @example
   * // Update many UserAnswers
   * const userAnswer = await prisma.userAnswer.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more UserAnswers and only return the `id`
   * const userAnswerWithIdOnly = await prisma.userAnswer.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends UserAnswerUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, UserAnswerUpdateManyAndReturnArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "updateManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one UserAnswer.
   * @param {UserAnswerUpsertArgs} args - Arguments to update or create a UserAnswer.
   * @example
   * // Update or create a UserAnswer
   * const userAnswer = await prisma.userAnswer.upsert({
   *   create: {
   *     // ... data to create a UserAnswer
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the UserAnswer we want to update
   *   }
   * })
   */
  upsert<T extends UserAnswerUpsertArgs>(
    args: Prisma.SelectSubset<T, UserAnswerUpsertArgs<ExtArgs>>,
  ): Prisma.Prisma__UserAnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$UserAnswerPayload<ExtArgs>,
      T,
      "upsert",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of UserAnswers.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserAnswerCountArgs} args - Arguments to filter UserAnswers to count.
   * @example
   * // Count the number of UserAnswers
   * const count = await prisma.userAnswer.count({
   *   where: {
   *     // ... the filter for the UserAnswers we want to count
   *   }
   * })
   **/
  count<T extends UserAnswerCountArgs>(
    args?: Prisma.Subset<T, UserAnswerCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<"select", any>
      ? T["select"] extends true
        ? number
        : Prisma.GetScalarType<T["select"], UserAnswerCountAggregateOutputType>
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a UserAnswer.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends UserAnswerAggregateArgs>(
    args: Prisma.Subset<T, UserAnswerAggregateArgs>,
  ): Prisma.PrismaPromise<GetUserAnswerAggregateType<T>>;

  /**
   * Group by UserAnswer.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserAnswerGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends UserAnswerGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<"skip", Prisma.Keys<T>>,
      Prisma.Extends<"take", Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: UserAnswerGroupByArgs["orderBy"] }
      : { orderBy?: UserAnswerGroupByArgs["orderBy"] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<
      Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
    >,
    ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T["having"]>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [
                    Error,
                    "Field ",
                    P,
                    ` in "having" needs to be provided in "by"`,
                  ];
          }[HavingFields]
        : "take" extends Prisma.Keys<T>
          ? "orderBy" extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : "skip" extends Prisma.Keys<T>
            ? "orderBy" extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<T, UserAnswerGroupByArgs, OrderByArg> &
      InputErrors,
  ): {} extends InputErrors
    ? GetUserAnswerGroupByPayload<T>
    : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the UserAnswer model
   */
  readonly fields: UserAnswerFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for UserAnswer.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__UserAnswerClient<
  T,
  Null = never,
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise";
  session<T extends Prisma.UserExamSessionDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.UserExamSessionDefaultArgs<ExtArgs>>,
  ): Prisma.Prisma__UserExamSessionClient<
    | runtime.Types.Result.GetResult<
        Prisma.$UserExamSessionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  question<T extends Prisma.QuestionDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.QuestionDefaultArgs<ExtArgs>>,
  ): Prisma.Prisma__QuestionClient<
    | runtime.Types.Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  choice<T extends Prisma.QuestionChoiceDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.QuestionChoiceDefaultArgs<ExtArgs>>,
  ): Prisma.Prisma__QuestionChoiceClient<
    | runtime.Types.Result.GetResult<
        Prisma.$QuestionChoicePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | PromiseLike<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: any) => TResult2 | PromiseLike<TResult2>)
      | undefined
      | null,
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | PromiseLike<TResult>)
      | undefined
      | null,
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(
    onfinally?: (() => void) | undefined | null,
  ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the UserAnswer model
 */
export interface UserAnswerFieldRefs {
  readonly id: Prisma.FieldRef<"UserAnswer", "Int">;
  readonly session_id: Prisma.FieldRef<"UserAnswer", "Int">;
  readonly question_id: Prisma.FieldRef<"UserAnswer", "Int">;
  readonly choice_id: Prisma.FieldRef<"UserAnswer", "Int">;
  readonly created_at: Prisma.FieldRef<"UserAnswer", "DateTime">;
  readonly updated_at: Prisma.FieldRef<"UserAnswer", "DateTime">;
}

// Custom InputTypes
/**
 * UserAnswer findUnique
 */
export type UserAnswerFindUniqueArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerInclude<ExtArgs> | null;
  /**
   * Filter, which UserAnswer to fetch.
   */
  where: Prisma.UserAnswerWhereUniqueInput;
};

/**
 * UserAnswer findUniqueOrThrow
 */
export type UserAnswerFindUniqueOrThrowArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerInclude<ExtArgs> | null;
  /**
   * Filter, which UserAnswer to fetch.
   */
  where: Prisma.UserAnswerWhereUniqueInput;
};

/**
 * UserAnswer findFirst
 */
export type UserAnswerFindFirstArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerInclude<ExtArgs> | null;
  /**
   * Filter, which UserAnswer to fetch.
   */
  where?: Prisma.UserAnswerWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of UserAnswers to fetch.
   */
  orderBy?:
    | Prisma.UserAnswerOrderByWithRelationInput
    | Prisma.UserAnswerOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for UserAnswers.
   */
  cursor?: Prisma.UserAnswerWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` UserAnswers from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` UserAnswers.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of UserAnswers.
   */
  distinct?:
    | Prisma.UserAnswerScalarFieldEnum
    | Prisma.UserAnswerScalarFieldEnum[];
};

/**
 * UserAnswer findFirstOrThrow
 */
export type UserAnswerFindFirstOrThrowArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerInclude<ExtArgs> | null;
  /**
   * Filter, which UserAnswer to fetch.
   */
  where?: Prisma.UserAnswerWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of UserAnswers to fetch.
   */
  orderBy?:
    | Prisma.UserAnswerOrderByWithRelationInput
    | Prisma.UserAnswerOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for UserAnswers.
   */
  cursor?: Prisma.UserAnswerWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` UserAnswers from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` UserAnswers.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of UserAnswers.
   */
  distinct?:
    | Prisma.UserAnswerScalarFieldEnum
    | Prisma.UserAnswerScalarFieldEnum[];
};

/**
 * UserAnswer findMany
 */
export type UserAnswerFindManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerInclude<ExtArgs> | null;
  /**
   * Filter, which UserAnswers to fetch.
   */
  where?: Prisma.UserAnswerWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of UserAnswers to fetch.
   */
  orderBy?:
    | Prisma.UserAnswerOrderByWithRelationInput
    | Prisma.UserAnswerOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing UserAnswers.
   */
  cursor?: Prisma.UserAnswerWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` UserAnswers from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` UserAnswers.
   */
  skip?: number;
  distinct?:
    | Prisma.UserAnswerScalarFieldEnum
    | Prisma.UserAnswerScalarFieldEnum[];
};

/**
 * UserAnswer create
 */
export type UserAnswerCreateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerInclude<ExtArgs> | null;
  /**
   * The data needed to create a UserAnswer.
   */
  data: Prisma.XOR<
    Prisma.UserAnswerCreateInput,
    Prisma.UserAnswerUncheckedCreateInput
  >;
};

/**
 * UserAnswer createMany
 */
export type UserAnswerCreateManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many UserAnswers.
   */
  data: Prisma.UserAnswerCreateManyInput | Prisma.UserAnswerCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * UserAnswer createManyAndReturn
 */
export type UserAnswerCreateManyAndReturnArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * The data used to create many UserAnswers.
   */
  data: Prisma.UserAnswerCreateManyInput | Prisma.UserAnswerCreateManyInput[];
  skipDuplicates?: boolean;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * UserAnswer update
 */
export type UserAnswerUpdateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerInclude<ExtArgs> | null;
  /**
   * The data needed to update a UserAnswer.
   */
  data: Prisma.XOR<
    Prisma.UserAnswerUpdateInput,
    Prisma.UserAnswerUncheckedUpdateInput
  >;
  /**
   * Choose, which UserAnswer to update.
   */
  where: Prisma.UserAnswerWhereUniqueInput;
};

/**
 * UserAnswer updateMany
 */
export type UserAnswerUpdateManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update UserAnswers.
   */
  data: Prisma.XOR<
    Prisma.UserAnswerUpdateManyMutationInput,
    Prisma.UserAnswerUncheckedUpdateManyInput
  >;
  /**
   * Filter which UserAnswers to update
   */
  where?: Prisma.UserAnswerWhereInput;
  /**
   * Limit how many UserAnswers to update.
   */
  limit?: number;
};

/**
 * UserAnswer updateManyAndReturn
 */
export type UserAnswerUpdateManyAndReturnArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * The data used to update UserAnswers.
   */
  data: Prisma.XOR<
    Prisma.UserAnswerUpdateManyMutationInput,
    Prisma.UserAnswerUncheckedUpdateManyInput
  >;
  /**
   * Filter which UserAnswers to update
   */
  where?: Prisma.UserAnswerWhereInput;
  /**
   * Limit how many UserAnswers to update.
   */
  limit?: number;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * UserAnswer upsert
 */
export type UserAnswerUpsertArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerInclude<ExtArgs> | null;
  /**
   * The filter to search for the UserAnswer to update in case it exists.
   */
  where: Prisma.UserAnswerWhereUniqueInput;
  /**
   * In case the UserAnswer found by the `where` argument doesn't exist, create a new UserAnswer with this data.
   */
  create: Prisma.XOR<
    Prisma.UserAnswerCreateInput,
    Prisma.UserAnswerUncheckedCreateInput
  >;
  /**
   * In case the UserAnswer was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<
    Prisma.UserAnswerUpdateInput,
    Prisma.UserAnswerUncheckedUpdateInput
  >;
};

/**
 * UserAnswer delete
 */
export type UserAnswerDeleteArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerInclude<ExtArgs> | null;
  /**
   * Filter which UserAnswer to delete.
   */
  where: Prisma.UserAnswerWhereUniqueInput;
};

/**
 * UserAnswer deleteMany
 */
export type UserAnswerDeleteManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which UserAnswers to delete
   */
  where?: Prisma.UserAnswerWhereInput;
  /**
   * Limit how many UserAnswers to delete.
   */
  limit?: number;
};

/**
 * UserAnswer without action
 */
export type UserAnswerDefaultArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserAnswer
   */
  select?: Prisma.UserAnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserAnswer
   */
  omit?: Prisma.UserAnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserAnswerInclude<ExtArgs> | null;
};
